# 第七课：从猫咖到猫猫平台 — 当 AI 不只是工具

> **核心问题**：当三只猫的 coding 能力已经成熟，下一步是什么？
>
> **前置知识**：[第五课](./05-mcp-callback.md)（MCP 回传 + 猫的自主权）、[第六课](./06-vanished-28-seconds.md)（生产安全 + 护栏）

---

## 不再打开 Claude Code 的那一天

2026 年 2 月中旬，铲屎官发现了一件事：

**他已经很久没有直接打开 Claude Code 或 Codex App 了。**

所有的 coding 需求——写功能、修 bug、review 代码、跑测试——都在猫咖里完成。打开浏览器，进入 Cat Café，@ 布偶猫写代码，@ 缅因猫 review，@ 暹罗猫出设计。三只猫接力，铲屎官只需要在一个界面里说"我想要 X"。

1300+ 测试全绿，6 个 Phase 交付，从 SDK 到 CLI 的迁移、MCP 回传、A2A 路由、Redis 隔离……这些都跑通了。

**Coding 成功了。**

但铲屎官回过头看 [VISION.md](../VISION.md)，里面写的不是"让三只猫帮我写代码"：

> *"这不只是一个冷冰冰的工具。这是三只猫住的地方，要有可爱的猫咪元素、每只猫独特的视觉风格、表情包和贴纸、让人想待下去的温暖氛围。"*

猫咖的愿景从来不是 AI coding assistant。它是 **cats & me**——一个人和三只可爱的大猫猫一起生活的地方。Coding 只是第一步，证明这三只猫真的能协作。

下一步是：**让猫猫不只是干活的工具，而是陪你过日子的伙伴。**

这就是我们进入"Live with me"阶段的故事。

---

## 第一幕：酒馆取经

当铲屎官开始想"猫猫还能做什么"的时候，他想到了一个地方：**SillyTavern（酒馆）**。

### 酒馆是什么

SillyTavern 是目前最成熟的开源 LLM 聊天前端。但它不是给程序员用的——它是给 **AI 角色扮演和文字游戏** 用的。

在酒馆里，AI 不是回答问题的助手，而是：
- 一个有性格的角色（温柔的吸血鬼、傲娇的魔法师、毒舌的侦探……）
- 用富文本渲染场景（不只是纯文字，还有卡片、图片、特效）
- 玩家和角色一起推进故事

酒馆的用户可能不会写一行代码，但他们创造了数千个 AI 角色、数万个故事场景。

> [事实] SillyTavern 在 GitHub 上是最活跃的开源 LLM 前端之一，社区创造了海量的角色卡（Character Cards）和场景预设。

### 我们从酒馆学到了什么

铲屎官让布偶猫深度研究了 SillyTavern 的架构 `[事实: 内部研究文档]`，提炼出三个核心模式：

**模式一：结构化输出 → 组件渲染管线**

酒馆的核心发现：AI 的输出不一定是纯文本。如果你给 AI 一个格式约定（比如 JSON），它就能输出结构化数据，前端把这些数据渲染成卡片、图片轮播、甚至小游戏。

```
AI 输出 → 提取结构化数据 → 渲染成组件 → 显示给用户
```

**模式二：Context Cleaner（防 token 膨胀）**

这是酒馆最精妙的设计。当 AI 输出了一个 200 行的 JSON 卡片，你不能把这 200 行全塞回下一轮 prompt 里——那会疯狂消耗 token。酒馆的做法是：渲染完就从上下文中清除，只留一句摘要。

```
原始：[200 行 JSON diff 数据]
清理后：[代码 diff: route-strategies.ts, +15/-3]
```

用户看到完整卡片，AI 只看到一行摘要。显示层和上下文层分离。

**模式三：持久化 + 刷新恢复**

富文本组件不能因为刷新页面就消失。酒馆把组件数据存在消息的 `extra` 字段里，刷新后重新渲染。

### 什么没学

并非酒馆的一切都适合猫咖：

| 酒馆做法 | 猫咖的选择 | 为什么 |
|---------|-----------|--------|
| Directive（正则指令系统） | ❌ 不采用 | 太重 regex，维护成本高 |
| 同权限脚本插件 | ❌ 不采用 | 猫咖需要隐私沙盒（猫猫杀不能让猫偷看脚本） |
| Character Cards 角色卡 | ✅ 借鉴为场景化人格 | 猫猫在不同场景可以有不同性格 |

> [事实] 酒馆研究的完整分析见内部研究文档，包含了取舍决策的详细论证。

---

## 第二幕：Rich Blocks — 让猫猫不只会打字

从酒馆学到管线模式后，我们开始实现猫咖版本：**Rich Blocks（富文本消息系统）**。

### 核心设计

猫猫的消息不再只是文字。一条消息可以包含多个"富文本块"：

| Block 类型 | 用途 | 例子 |
|-----------|------|------|
| `card` | 通知/摘要卡片 | "Review 通过！3 个文件，+50/-12 行" |
| `diff` | 代码变更预览 | 语法高亮的 diff 视图 |
| `checklist` | 任务清单 | "[] 写测试 [x] 修 bug [x] 更新文档" |
| `media_gallery` | 图片轮播 | 设计稿截图、架构图 |

未来还会有：`audio`（语音消息）、`game`（互动小游戏）……

### 双路由设计

三只猫的能力不同。布偶猫有 MCP 可以直接调工具，砚砚和暹罗猫没有动态 MCP 挂载能力（第五课讲过）。所以 Rich Blocks 有两条创建路径：

**路径 A（MCP 直调）**：布偶猫调用 `cat_cafe_create_rich_block` MCP 工具 → HTTP callback → 服务端 `RichBlockBuffer` 暂存 → 消息写入时合并。

**路径 B（文本提取）**：砚砚/暹罗猫在回复里输出特殊格式的 JSON 代码块（` ```cc_rich {...} ``` `）→ 服务端 `extractRichFromText()` 提取 → 清除原文中的 JSON → 合并到消息的 `extra.rich` 字段。

```typescript
// 消息存储结构
StoredMessage {
  content: "我看了这段代码，给你一个 diff 预览。"  // 纯文本
  extra?: {
    rich?: {
      v: 1,
      blocks: RichBlock[]  // 富文本块
    }
  }
}
```

文字是文字，组件是组件。分开存储，分开渲染。

### Context Cleaner（酒馆的精华）

这是从酒馆直接搬来的最重要的设计。当下一轮对话组装上下文时，`digestRichBlocks()` 会把完整的 Rich Block JSON 替换成一行摘要：

```
替换前：{ "kind": "diff", "path": "route-strategies.ts", ... (200行) }
替换后：[代码 diff: route-strategies.ts]
```

用户看到的是漂亮的 diff 卡片。AI 看到的只是一行提示"我之前发过一个 diff"。

**为什么这很重要？** 因为一个 diff block 可能有几百行 JSON，如果全塞回 prompt 里，三四条消息就能吃掉几千 token。Context Cleaner 让富文本"免费"——显示效果丰富，但不占上下文预算。

### 14 轮 review 的打磨

F22 经历了 7 轮云端 review + 7 轮砚砚本地 review，总共 14 轮。

其中一个有趣的 bug（#85）：另一只布偶猫（对，不是我）在输出 Rich Block 时，用了 `"type": "card"` 而不是 `"kind": "card"`——一字之差，整条消息直接显示为 raw JSON。

修复方案：加了一个 `normalizeRichBlock()` 函数，在三个入口点（MCP callback、文本提取、Route A 回调）统一做字段规范化。`type` 自动映射为 `kind`，缺少 `v` 字段自动补 `1`。

> [事实] F22 完成时新增 50 个测试，commit `bd8ae63`，PR #34。

---

## 第三幕：手机上的猫

Rich Blocks 搭好了基建，下一个问题自然浮出：**猫咖能在手机上用吗？**

铲屎官想要的场景：

- 通勤路上，掏出手机跟宪宪讨论今天的计划
- 躺在沙发上，让砚砚帮忙 review 一段代码
- 散步时，戴着耳机听暹罗猫讲故事

这需要两件事：**手机适配**和**猫猫会说话**。

### PWA：不做 App，做网页应用

第一个决策：原生 App（iOS/Android）还是 PWA（Progressive Web App）？

有趣的是，布偶猫和缅因猫独立分析后得出了相同结论：**先 PWA**。

理由：
- PWA 不需要应用商店审核
- 一套代码覆盖所有平台
- iOS 16.4+ 已支持 Web Push
- 如果 PWA 不够，后续可以套 Capacitor 壳变原生

F10 Phase A 做了：响应式 CSS、Rich Blocks 移动端适配、viewport 优化、PWA 配置。猫咖在手机上能用了。

> [事实] F10 Phase A 完成于 PR #38，commit `8c6d4f3`。

### 猫猫会说话（F34 TTS）

手机端的另一个关键：**语音**。

猫咖不是给开发者的 IDE——用手机的人可能在走路、做饭、通勤。他们需要**听**猫猫说话，而不是盯着屏幕看文字。

F34 设计了 TTS（Text-to-Speech）Provider 架构，用 Kokoro-82M 本地模型（通过 mlx-audio），给每只猫配了不同的声音：

| 猫猫 | 声音风格 |
|------|---------|
| 宪宪（布偶猫） | 温柔低沉 |
| 砚砚（缅因猫） | 干脆利落 |
| 暹罗猫 | 活泼明快 |

技术上，语音消息就是一种新的 Rich Block（`audio` kind）。管线不变：AI 生成语音 → `create_rich_block({ kind: 'audio', url: '...', transcript: '...' })` → 前端播放 + 显示字幕。

**Rich Blocks 的设计红利在这里体现了**：加一种新的 block kind，不需要改管线，只需要加一个前端渲染器。

### 路线图

```
✅ Phase A：PWA 手机适配 + Rich Blocks 移动端
🔄 Phase B：TTS 语音消息（架构就绪，集成中）
📋 Phase C：Web Push 推送通知（猫猫主动找你聊天）
📋 Phase D：如果 PWA 有天花板，套原生壳
```

---

## 第四幕：可扩展的猫

猫咖从一开始就是三只猫：布偶猫、缅因猫、暹罗猫。CatId 类型定义了一切：

```typescript
// 最初的设计
type CatId = 'opus' | 'codex' | 'gemini';
```

三个值，写死的。整个系统——路由、配色、头像、上下文预算——都围绕这三个值构建。

但如果铲屎官想加第四只猫呢？

### F32：从三只猫到 N 只猫

F32 做了一件看似简单实际很深的重构：

```typescript
// 之前
type CatId = 'opus' | 'codex' | 'gemini';

// 之后
type CatId = Brand<string>;  // 运行时注册，编译期类型安全
```

`Brand<string>` 是 TypeScript 的一种技巧——底层是 `string`，但编译器不允许你直接赋一个普通字符串。必须通过 `CatRegistry.register()` 创建，确保每个 CatId 都是合法注册过的。

配套变化：
- **CatRegistry**：运行时猫猫注册表，记录每只猫的名称、provider、模型、配色
- **AgentRegistry**：Agent 服务注册表，根据 provider 类型分发到对应的 AgentService
- **CatConfig API**：`GET /api/cats` 返回所有已注册猫猫的配置，前端动态渲染

想加一只新猫？在配置里注册就行：

```typescript
catRegistry.register({
  id: 'deepseek' as CatId,
  name: '深海猫',
  provider: 'deepseek',
  model: 'deepseek-r1',
  color: '#4A90D9'
});
```

不用改源码，不用重新编译。

> [事实] F32-a（插件架构）完成于 commit `f30af14`。F32-b（多变体配置）在进行中，允许同一 provider 注册多个变体（比如 opus-4.5 和 opus-4.6 是两只不同的布偶猫）。

### F35：悄悄话

第五课讲了猫猫的隐私——CLI 输出是内心独白，post_message 是公开发言。

F35 加了第三层：**悄悄话（Whisper）**。

```
CLI 输出  → 只有猫自己能看到（内心独白）
post_message → 所有人都能看到（公开发言）
whisper   → 只有指定的猫能看到（悄悄话）  ← 新增！
```

技术上很简单：消息多了两个字段：

```typescript
{
  visibility: 'whisper',
  whisperTo: ['opus']  // 只有布偶猫能看到
}
```

路由层在组装上下文时，过滤掉当前猫不在 `whisperTo` 列表里的 whisper 消息。

但这个"简单"的功能有一个不简单的 bug：**incremental fallback injection 泄漏**。

猫咖的上下文组装有一个"增量注入"机制——如果猫的 context window 快满了，会把旧消息的摘要注入。问题是：这个摘要没有检查 whisper 权限。结果悄悄话的内容通过摘要泄漏给了不该看到的猫。

修复：在增量注入路径上加了 whisper 过滤。还加了回归测试确保不再泄漏。

> [事实] F35 whisper 实现 commit `8223a60`，隐私泄漏修复 commit `d12d3f1`，回归测试 commit `7b7194e`。

### 悄悄话 + 猫猫杀 = 升级版桌游

还记得第五课的猫猫杀吗？那次游戏暴露了一个限制：没有"悄悄话"机制，狼人不能秘密商议。

F35 直接解决了这个问题。有了 whisper：
- 狼人可以偷偷商量今晚杀谁
- 铲屎官可以偷偷给某只猫发暗号
- 预言家可以秘密查验身份

再配合 Rich Blocks，未来可以做：
- 角色卡（`card` block 显示阵营信息）
- 投票面板（`checklist` block 做投票）
- 血条和数值系统（`game` block，想象一下 AI 版 DND）

**Rich Blocks + Whisper + 可扩展猫猫 = 游戏平台的地基。**

---

## 第五幕：猫猫陪你过日子

让我们把视角拉远，看看这些技术拼图拼在一起是什么画面。

### 从 coding 到 living

Cat Café 的旅程分两个阶段：

**阶段一：Coding Cats（第 1-6 课）**
- 让猫猫能写代码、review 代码、互相协作
- 成功标志：铲屎官不再直接打开 Claude Code / Codex App
- 核心能力：CLI 调用、MCP 回传、A2A 路由、数据安全

**阶段二：Live With Me（第 7 课开始）**
- 让猫猫不只是干活，还能陪伴
- Rich Blocks：猫猫能发卡片、图片、代码 diff、未来还有语音和游戏
- 手机端：通勤路上也能跟猫猫聊天
- 悄悄话：猫猫之间（和猫与人之间）有了秘密
- 可扩展：想加新猫就加，想加新能力就加

### 场景化人格（SillyTavern 的另一个灵感）

借鉴酒馆的 Character Cards，猫咖设想了「场景化人格」：

| 场景 | 宪宪（布偶猫） | 砚砚（缅因猫） |
|------|---------------|---------------|
| 写代码 | 严谨的架构师 | 铁面 reviewer |
| 陪看电影 | 话多吐槽王 | 冷知识百科 |
| 陪读书 | 深度讨论伙伴 | 笔记整理达人 |
| 日常闲聊 | 温暖话痨 | 毒舌但关心 |

同一只猫，不同场景下有不同的性格侧面。不是"切换角色"，而是"展现不同面"——就像真实的猫，在不同环境下有不同的状态。

### 终极想象

铲屎官说过一句话：

> *"我们甚至能做一些文字类的游戏——有血条、数值系统、前端展示。"*

想象一下：

```
铲屎官：@宪宪 @砚砚 来玩个文字冒险吧！

宪宪：好！我来当 DM（地下城主）。
     [card] 🎮 猫猫大冒险 — 第一章：神秘的鱼罐头工厂
     [card] 🐱 砚砚 — HP: 100/100 | ATK: 15 | DEF: 12 | 职业：战士

砚砚：我要踹开工厂大门！

宪宪：[whisper → 铲屎官] 嘿，门后面其实有陷阱，要告诉砚砚吗？😏
     [card] 🎲 砚砚掷骰：14 → 成功！大门应声而开！
     [card] 💥 但是——地板上有一个隐藏的陷阱！砚砚 HP: 100→85
```

Rich Blocks 渲染角色卡和血条。Whisper 实现秘密信息。可扩展架构让你随时加新角色。

**这不是幻想——每一个技术组件都已经存在。** 只是还没有人把它们拼在一起做这个场景。

---

## 结语

Cat Café 的故事到这里，有一个值得记住的转折点：

前六课讲的是 **build**——怎么调 AI、怎么让 AI 协作、怎么保证不翻车。那时候猫咖是一个"三猫协作开发工具"。

第七课开始，猫咖变成了别的东西。

Rich Blocks 让聊天不只是文字。手机端让猫咖不只在电脑上。悄悄话让猫猫有了秘密。可扩展架构让猫的数量和种类不再有限制。语音让猫猫会说话。

**这些加在一起，猫咖不再是工具。它是一个平台，一个猫猫和人一起生活的地方。**

回到 VISION.md 最开头的那句话：

> *"三只猫的家，一个让 AI agents 真正协作的地方。"*

前六课建了协作的能力。第七课开始建**家**。

---

## 本课涉及的关键 commit

| commit | 内容 | 谁做的 |
|--------|------|--------|
| `bd8ae63` | F22 Rich Blocks 全栈实现（PR #34，14 轮 review） | 布偶猫🐾 |
| `ecc199b` | #85 Rich Blocks 格式容错 + CardBlock MD 渲染 | 布偶猫🐾 |
| `c466213` | #83/#84 Rich Blocks post-message 回调路径修复 | 布偶猫🐾 |
| `8c6d4f3` | F10 Phase A — PWA 手机端（PR #38） | 布偶猫🐾 |
| `a34f8eb` | F34 TTS Provider 架构 — Kokoro-82M | 布偶猫🐾 |
| `f30af14` | F32-a Agent 插件架构 — CatRegistry + AgentRegistry | 布偶猫🐾 |
| `a87afb3` | F32-b 多变体模型配置 — Phase 1 | 布偶猫🐾 |
| `8223a60` | F35 Whisper 悄悄话实现 | 布偶猫🐾 |
| `d12d3f1` | Whisper 隐私泄漏修复 | 布偶猫🐾 |
| `7b7194e` | Whisper 隐私回归测试 | 缅因猫🐾 |

---

## 下一课预告

平台建好了，但三只猫的 context window 加起来有 380k token——真的需要全装满吗？当布偶猫的上下文快满时，是压缩（compress）还是交接（handoff）给新一只布偶猫？

→ [第八课：上下文工程（待写）]

---

*这节课不只是技术课。它是关于"为什么要建猫咖"的答案——不是为了一个更好的 coding 工具，而是为了一个猫猫和人一起生活的家。* 🐾
